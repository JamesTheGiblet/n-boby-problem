<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>N-Body Gravity Ultimate (Octree)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
    *{margin:0;padding:0;box-sizing:border-box;}
    body{
        background:#000;
        color:#0ff;
        font-family:'Courier New',monospace;
        display:flex;
        flex-direction:column;
        height:100vh;
        overflow:hidden;
        touch-action:none;
        image-rendering:pixelated;
    }
    #ui{
        position:absolute;
        top:10px;left:10px;right:10px;
        display:flex;
        flex-wrap:wrap;
        gap:8px;
        z-index:10;
        pointer-events:none;
    }
    .btn{
        padding:8px 12px;
        background:rgba(0,255,255,0.2);
        color:#0ff;
        border:2px solid #0ff;
        border-radius:8px;
        font-family:inherit;
        font-weight:bold;
        font-size:0.8rem;
        pointer-events:all;
        touch-action:manipulation;
        cursor:pointer;
    }
    .btn:active{background:rgba(0,255,255,0.5);transform:scale(0.95);}
    .btn.repulsor{background:rgba(255,0,0,0.3);border-color:#f00;color:#f00;}
    .btn.template{background:rgba(255,255,0,0.3);border-color:#ff0;color:#ff0;}
    .btn.focus{background:rgba(255,165,0,0.3);border-color:#fa0;color:#fa0;}
    .btn.sun{background:rgba(255,200,0,0.3);border-color:#fc0;color:#fc0;}
    .slider{
        -webkit-appearance:none;
        width:100px;
        height:6px;
        background:rgba(0,255,255,0.2);
        border-radius:3px;
        outline:none;
        pointer-events:all;
    }
    .slider::-webkit-slider-thumb{
        -webkit-appearance:none;
        width:16px;height:16px;
        background:#0ff;
        border-radius:50%;
        cursor:pointer;
    }
    .slider::-moz-range-thumb{
        width:16px;height:16px;
        background:#0ff;
        border-radius:50%;
        cursor:pointer;
        border:none;
    }
    canvas{
        flex:1;
        background:#000;
        image-rendering:pixelated;
    }
    .info{
        position:absolute;
        bottom:10px;left:10px;
        background:rgba(0,0,0,0.7);
        padding:6px 10px;
        border:1px solid #0ff;
        border-radius:6px;
        font-size:0.7rem;
        max-width:90%;
    }
    .save-list{
        position:absolute;
        top:60px;left:10px;
        background:rgba(0,0,0,0.9);
        border:1px solid #0ff;
        padding:10px;
        border-radius:8px;
        max-height:200px;
        overflow-y:auto;
        display:none;
        z-index:20;
    }
    .save-item{
        padding:6px;
        background:rgba(0,255,255,0.1);
        margin:4px 0;
        border-radius:4px;
        cursor:pointer;
        font-size:0.7rem;
    }
    .save-item:hover{background:rgba(0,255,255,0.3);}
</style>
</head>
<body>

<div id="ui">
    <button class="btn" id="pause">Pause</button>
    <button class="btn" id="clear">Clear</button>
    <button class="btn template" id="spiral">Spiral Galaxy</button>
    <button class="btn template" id="elliptical">Elliptical</button>
    <button class="btn template" id="milky">Milky Way</button>
    <button class="btn template" id="andromeda">Andromeda</button>
    <button class="btn sun" id="solarSystem">Solar System</button>
    <button class="btn" id="blackHole">Black Hole</button>
    <button class="btn focus" id="focus">Focus Largest</button>
    <button class="btn repulsor" id="repulsor">Repulsor: OFF</button>
    <button class="btn" id="darkMatter">Dark Matter: OFF</button>
    <button class="btn" id="threed">3D: OFF</button>
    <button class="btn" id="save">Save</button>
    <button class="btn" id="load">Load</button>
    <button class="btn" id="trail">Trail: ON</button>
    
    <label>Mass: <input type="range" class="slider" id="mass" min="1" max="50" value="10"></label>
    <label>Speed: <input type="range" class="slider" id="speed" min="0.1" max="3" step="0.1" value="1"></label>
</div>

<div class="info" id="info">Bodies: 0 | Hold & drag | F = G·m₁·m₂ / r²</div>

<div class="save-list" id="saveList"></div>

<canvas id="c"></canvas>

<script>
// ================================
// N-BODY GRAVITY ULTIMATE+ (OCTREE + SUNS & MOONS)
// ================================

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const G = 50;
let bodies = [];
let paused = false;
let showTrail = true;
let mass = 10;
let speed = 1;
let isRepulsor = false;
let darkMatter = false;
let is3D = false;
let explosionParticles = [];
let camera = { x: 0, y: 0, z: 500, rotX: 0, rotY: 0, zoom: 1, velX: 0, velY: 0, velZ: 0 };
let trackedBody = null;
let rootNode;

// ——— KEYBOARD/CAMERA CONTROLS ———
const keys = {};
window.addEventListener('keydown', e => {
    if (['w', 'a', 's', 'd', 'q', 'e', ' '].includes(e.key.toLowerCase())) e.preventDefault();
    keys[e.key.toLowerCase()] = true;
    if (e.key === ' ') document.getElementById('pause').click();
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function updateCamera(dt) {
    if (trackedBody) {
        if (!bodies.includes(trackedBody)) {
            trackedBody = null;
            document.getElementById('focus').textContent = "Focus Largest";
        } else {
            const idealZ = is3D ? trackedBody.z + 400 / camera.zoom : 500;
            camera.x += (trackedBody.x - camera.x) * 0.1;
            camera.y += (trackedBody.y - camera.y) * 0.1;
            camera.z += (idealZ - camera.z) * 0.1;
            camera.velX = 0; camera.velY = 0; camera.velZ = 0;
            return;
        }
    }

    if (!is3D) { camera.velX = 0; camera.velY = 0; camera.velZ = 0; return; }

    const moveSpeed = 800 * dt;
    const maxSpeed = 50;
    const sinY = Math.sin(camera.rotY), cosY = Math.cos(camera.rotY);

    if (keys['w']) { camera.velX -= sinY * moveSpeed; camera.velZ -= cosY * moveSpeed; }
    if (keys['s']) { camera.velX += sinY * moveSpeed; camera.velZ += cosY * moveSpeed; }
    if (keys['a']) { camera.velX -= cosY * moveSpeed; camera.velZ += sinY * moveSpeed; }
    if (keys['d']) { camera.velX += cosY * moveSpeed; camera.velZ -= sinY * moveSpeed; }
    if (keys['q']) camera.velY -= moveSpeed;
    if (keys['e']) camera.velY += moveSpeed;

    camera.velX = Math.max(-maxSpeed, Math.min(maxSpeed, camera.velX));
    camera.velY = Math.max(-maxSpeed, Math.min(maxSpeed, camera.velY));
    camera.velZ = Math.max(-maxSpeed, Math.min(maxSpeed, camera.velZ));

    camera.x += camera.velX * dt; camera.y += camera.velY * dt; camera.z += camera.velZ * dt;
    camera.velX *= 0.95; camera.velY *= 0.95; camera.velZ *= 0.95;
}

// ——— SAVE/LOAD ———
function saveGalaxy(name) {
    const data = bodies.map(b => ({
        x: b.x, y: b.y, z: b.z || 0, vx: b.vx, vy: b.vy, vz: b.vz || 0,
        m: b.m, color: b.color, charge: b.charge, isStatic: b.isStatic || false,
        isSun: b.isSun || false, parent: b.parent ? bodies.indexOf(b.parent) : -1
    }));
    const saves = JSON.parse(localStorage.getItem('gravitySaves') || '{}');
    saves[name] = data;
    localStorage.setItem('gravitySaves', JSON.stringify(saves));
    updateSaveList();
}
function loadGalaxy(name) {
    const saves = JSON.parse(localStorage.getItem('gravitySaves') || '{}');
    const data = saves[name];
    if (!data) return;
    bodies = data.map(d => {
        const b = d.isStatic ? new BlackHole(d.x, d.y, d.m) : new Body(d.x, d.y, d.z || 0, d.vx, d.vy, d.vz || 0, d.m, d.color, d.charge);
        if (d.isSun) b.isSun = true;
        return b;
    });
    bodies.forEach((b, i) => {
        const d = data[i];
        if (d.parent >= 0) b.parent = bodies[d.parent];
    });
    updateInfo();
}
function updateSaveList() {
    const list = document.getElementById('saveList');
    const saves = JSON.parse(localStorage.getItem('gravitySaves') || '{}');
    list.innerHTML = '';
    Object.keys(saves).forEach(name => {
        const div = document.createElement('div');
        div.className = 'save-item';
        div.textContent = name;
        div.onclick = () => { loadGalaxy(name); list.style.display = 'none'; };
        list.appendChild(div);
    });
    list.style.display = Object.keys(saves).length ? 'block' : 'none';
}

// ——— BODY CLASS (3D + SUNS & MOONS) ———
class Body {
    constructor(x, y, z, vx, vy, vz, m, color, charge = 1) {
        this.x = x; this.y = y; this.z = z;
        this.vx = vx; this.vy = vy; this.vz = vz;
        this.m = m;
        this.r = Math.cbrt(m) * 1.5;
        this.color = color;
        this.charge = charge;
        this.trail = [];
        this.cometTail = [];
        this.orbitPath = [];
        this.ax = 0; this.ay = 0; this.az = 0;
        this.isSun = false;
        this.parent = null;
    }

    applyPhysics(dt) {
        if (this.isStatic) return;

        if (darkMatter) {
            const pull = 0.01 * G;
            this.ax -= this.x * pull * dt;
            this.ay -= this.y * pull * dt;
            this.az -= this.z * pull * dt;
            this.vx *= 0.999; this.vy *= 0.999; this.vz *= 0.999;
        }
        
        this.vx += this.ax * dt;
        this.vy += this.ay * dt;
        this.vz += this.az * dt;
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.z += this.vz * dt;
        
        this.ax = 0; this.ay = 0; this.az = 0;

        if (this.parent) this.updateOrbitPath();
    }

    updateEffects(dt) {
        const speed = Math.hypot(this.vx, this.vy, this.vz);
        if (speed > 5) {
            this.cometTail.push({x: this.x, y: this.y, z: this.z, a: 1});
            if (this.cometTail.length > 30) this.cometTail.shift();
        }
        this.cometTail.forEach(p => p.a *= 0.95);

        if (showTrail) {
            this.trail.push({x:this.x, y:this.y, z:this.z});
            if (this.trail.length > 100) this.trail.shift();
        }

        if (this.m > 300 && !this.exploded) this.explode();
    }

    explode() {
        this.exploded = true;
        const count = 30 + Math.floor(this.m / 10);
        for (let i = 0; i < count; i++) {
            const v = 50 + Math.random() * 100;
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            explosionParticles.push({
                x: this.x, y: this.y, z: this.z,
                vx: v * Math.sin(phi) * Math.cos(theta),
                vy: v * Math.sin(phi) * Math.sin(theta),
                vz: v * Math.cos(phi),
                life: 1, color: `hsl(${Math.random()*60},100%,70%)`
            });
        }
        bodies = bodies.filter(b => b !== this);
    }

    updateOrbitPath() {
        if (!this.parent) return;
        const dx = this.parent.x - this.x, dy = this.parent.y - this.y, dz = this.parent.z - this.z;
        const dist = Math.hypot(dx, dy, dz);
        const period = 2 * Math.PI * Math.sqrt(dist**3 / (G * this.parent.m));
        const steps = 60;
        this.orbitPath = [];
        for (let i = 0; i < steps; i++) {
            const t = i / steps * period;
            const angle = t * Math.sqrt(G * this.parent.m / dist**3);
            const ox = this.parent.x + (this.x - this.parent.x) * Math.cos(angle) - (this.y - this.parent.y) * Math.sin(angle);
            const oy = this.parent.y + (this.x - this.parent.x) * Math.sin(angle) + (this.y - this.parent.y) * Math.cos(angle);
            this.orbitPath.push({x: ox, y: oy, z: this.z});
        }
    }

    draw() {
        const {sx, sy, scale} = this.project();
        if (scale <= 0) return;

        // Orbit Path (dashed)
        if (this.parent && this.orbitPath.length > 1) {
            ctx.strokeStyle = '#0ff40';
            ctx.lineWidth = 1 * scale;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            let p = this.orbitPath[0];
            const pp = p.project();
            ctx.moveTo(pp.sx, pp.sy);
            for (let i = 1; i < this.orbitPath.length; i++) {
                p = this.orbitPath[i];
                const pp = p.project();
                ctx.lineTo(pp.sx, pp.sy);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Sun Glow
        if (this.isSun) {
            const glow = Math.min(this.m / 10, 50) * scale;
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = glow;
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.arc(sx, sy, this.r * 1.5 * scale, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // Comet tail
        if (this.cometTail.length > 1) {
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2 * scale;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            let first = this.cometTail[0].project();
            ctx.moveTo(first.sx, first.sy);
            for (let i = 1; i < this.cometTail.length; i++) {
                const p = this.cometTail[i];
                const {sx, sy} = p.project();
                ctx.globalAlpha = p.a;
                ctx.lineTo(sx, sy);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        // Trail
        if (showTrail && this.trail.length > 1) {
            ctx.strokeStyle = this.color + '40';
            ctx.lineWidth = 1 * scale;
            ctx.beginPath();
            const first = this.trail[0].project();
            ctx.moveTo(first.sx, first.sy);
            for (let p of this.trail) {
                const {sx, sy} = p.project();
                ctx.lineTo(sx, sy);
            }
            ctx.stroke();
        }

        // Body
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(sx, sy, this.r * scale, 0, Math.PI*2);
        ctx.fill();
    }

    project() {
        let px = this.x - camera.x;
        let py = this.y - camera.y;
        let pz = this.z - camera.z;

        if (is3D) {
            const cosX = Math.cos(camera.rotX), sinX = Math.sin(camera.rotX);
            const cosY = Math.cos(camera.rotY), sinY = Math.sin(camera.rotY);
            let pz1 = pz * cosY - px * sinY;
            let px1 = pz * sinY + px * cosY;
            let py1 = py * cosX - pz1 * sinX;
            let pz2 = py * sinX + pz1 * cosX;
            px = px1; py = py1; pz = pz2;
            const fov = 300;
            const scale = fov / (fov + pz);
            return { sx: px * scale + W/2, sy: py * scale + H/2, scale: Math.max(0, scale * camera.zoom) };
        } else {
            return { sx: px * camera.zoom + W/2, sy: py * camera.zoom + H/2, scale: camera.zoom };
        }
    }
}
Object.prototype.project = Body.prototype.project;

// ——— BLACK HOLE ———
class BlackHole extends Body {
    constructor(x, y, m) {
        super(x, y, 0, 0, 0, 0, m, '#fff', 1);
        this.isStatic = true;
        this.r = Math.cbrt(m) * 0.5;
    }
    applyPhysics() {}
    updateEffects() {}
    draw() {
        const {sx, sy, scale} = this.project();
        if (scale <= 0) return;
        ctx.strokeStyle = '#0ff';
        ctx.shadowColor = '#0ff';
        ctx.shadowBlur = 30 * scale;
        ctx.lineWidth = 4 * scale;
        ctx.beginPath();
        ctx.arc(sx, sy, (this.r + 8) * scale, 0, Math.PI*2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(sx, sy, this.r * scale, 0, Math.PI*2);
        ctx.fill();
    }
}

// ——— OCTREE ———
class OctreeNode {
    constructor(center, size) {
        this.center = center; this.size = size;
        this.children = Array(8).fill(null);
        this.body = null; this.isLeaf = true;
        this.totalMass = 0; this.centerOfMass = {x:0,y:0,z:0};
    }
    insert(body) {
        if (this.totalMass > 0) this.updateCenterOfMass(body);
        else { this.totalMass = body.m; this.centerOfMass = {x:body.x,y:body.y,z:body.z}; }
        if (this.isLeaf && this.body === null) { this.body = body; return; }
        if (this.isLeaf) { this.isLeaf = false; this.subdivide(this.body); this.body = null; }
        this.subdivide(body);
    }
    subdivide(body) {
        const oct = this.getOctant(body);
        if (!this.children[oct]) {
            const s = this.size / 2;
            this.children[oct] = new OctreeNode(this.getChildCenter(oct, s/2), s);
        }
        this.children[oct].insert(body);
    }
    calculateForce(target, theta = 0.5) {
        if (this.isLeaf && this.body) return this.directForce(target, this.body);
        const dx = this.centerOfMass.x - target.x, dy = this.centerOfMass.y - target.y, dz = this.centerOfMass.z - target.z;
        const d = Math.hypot(dx, dy, dz);
        if (this.size / d < theta || this.isLeaf) return this.directForce(target, {x:this.centerOfMass.x, y:this.centerOfMass.y, z:this.centerOfMass.z, m:this.totalMass, charge:1});
        let f = {x:0,y:0,z:0};
        for (const child of this.children) if (child) {
            const cf = child.calculateForce(target, theta);
            f.x += cf.x; f.y += cf.y; f.z += cf.z;
        }
        return f;
    }
    directForce(b1, b2) {
        if (!b2 || b1 === b2) return {x:0,y:0,z:0};
        const dx = b2.x - b1.x, dy = b2.y - b1.y, dz = b2.z - b1.z;
        const d2 = dx*dx + dy*dy + dz*dz; if (d2 < 1) return {x:0,y:0,z:0};
        const d = Math.sqrt(d2), f = (G * b2.m / d2) * (b1.charge * (b2.charge ?? 1));
        return {x: f * dx / d, y: f * dy / d, z: f * dz / d};
    }
    updateCenterOfMass(b) {
        const t = this.totalMass + b.m;
        this.centerOfMass.x = (this.centerOfMass.x * this.totalMass + b.x * b.m) / t;
        this.centerOfMass.y = (this.centerOfMass.y * this.totalMass + b.y * b.m) / t;
        this.centerOfMass.z = (this.centerOfMass.z * this.totalMass + b.z * b.m) / t;
        this.totalMass = t;
    }
    getOctant(b) {
        let o = 0;
        if (b.x > this.center.x) o |= 1;
        if (b.y > this.center.y) o |= 2;
        if (b.z > this.center.z) o |= 4;
        return o;
    }
    getChildCenter(o, s) {
        return {x: this.center.x + (o&1?s:-s), y: this.center.y + (o&2?s:-s), z: this.center.z + (o&4?s:-s)};
    }
}

// ——— GALAXY TEMPLATES ———
function generateSpiralGalaxy(n = 200) {
    bodies = [];
    const cx = W/2, cy = H/2;
    const centerMass = new Body(cx, cy, 0, 0, 0, 0, 100, '#fff', 1);
    bodies.push(centerMass);
    
    for (let i = 0; i < n; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = 50 + Math.random() * 300;
        const armAngle = angle + r / 50;
        const x = cx + Math.cos(armAngle) * r;
        const y = cy + Math.sin(armAngle) * r;
        const orbitalSpeed = Math.sqrt(G * centerMass.m / r) * (0.8 + Math.random() * 0.4);
        const vx = -Math.sin(armAngle) * orbitalSpeed;
        const vy = Math.cos(armAngle) * orbitalSpeed;
        const m = 1 + Math.random() * 3;
        const hue = (i * 360 / n) % 360;
        bodies.push(new Body(x, y, 0, vx, vy, 0, m, `hsl(${hue},100%,70%)`, 1));
    }
    updateInfo();
}

function generateEllipticalGalaxy(n = 150) {
    bodies = [];
    const cx = W/2, cy = H/2;
    const centerMass = new Body(cx, cy, 0, 0, 0, 0, 150, '#fff', 1);
    bodies.push(centerMass);
    
    for (let i = 0; i < n; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 50 + Math.random() * 200;
        const x = cx + r * Math.sin(phi) * Math.cos(theta);
        const y = cy + r * Math.sin(phi) * Math.sin(theta) * 0.6;
        const z = r * Math.cos(phi) * 0.4;
        
        const speed = Math.sqrt(G * centerMass.m / r) * (0.5 + Math.random() * 0.3);
        const vx = -Math.sin(theta) * speed * Math.sin(phi);
        const vy = Math.cos(theta) * speed * Math.sin(phi) * 0.6;
        const vz = 0;
        
        const m = 1 + Math.random() * 2;
        const hue = 30 + Math.random() * 60;
        bodies.push(new Body(x, y, z, vx, vy, vz, m, `hsl(${hue},100%,70%)`, 1));
    }
    updateInfo();
}

function generateMilkyWay(n = 300) {
    bodies = [];
    const cx = W/2, cy = H/2;
    const centerMass = new Body(cx, cy, 0, 0, 0, 0, 200, '#fff', 1);
    bodies.push(centerMass);
    
    const arms = 4;
    for (let i = 0; i < n; i++) {
        const arm = Math.floor(i / (n / arms));
        const baseAngle = (arm / arms) * Math.PI * 2;
        const r = 30 + Math.random() * 350;
        const armSpiral = r / 60;
        const angle = baseAngle + armSpiral + (Math.random() - 0.5) * 0.5;
        
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;
        const z = (Math.random() - 0.5) * 20;
        
        const orbitalSpeed = Math.sqrt(G * centerMass.m / r) * (0.9 + Math.random() * 0.2);
        const vx = -Math.sin(angle) * orbitalSpeed;
        const vy = Math.cos(angle) * orbitalSpeed;
        const vz = 0;
        
        const m = 0.5 + Math.random() * 2.5;
        const hue = 180 + arm * 30 + Math.random() * 30;
        bodies.push(new Body(x, y, z, vx, vy, vz, m, `hsl(${hue},100%,70%)`, 1));
    }
    updateInfo();
}

function generateAndromeda(n = 400) {
    bodies = [];
    const cx = W/2, cy = H/2;
    const centerMass = new Body(cx, cy, 0, 0, 0, 0, 250, '#fff', 1);
    bodies.push(centerMass);
    
    const arms = 2;
    for (let i = 0; i < n; i++) {
        const arm = i % arms;
        const baseAngle = (arm / arms) * Math.PI * 2;
        const r = 40 + Math.random() * 400;
        const spiral = r / 50;
        const angle = baseAngle + spiral + (Math.random() - 0.5) * 0.3;
        
        const x = cx + Math.cos(angle) * r * 1.2;
        const y = cy + Math.sin(angle) * r * 0.8;
        const z = (Math.random() - 0.5) * 30;
        
        const orbitalSpeed = Math.sqrt(G * centerMass.m / r) * (0.85 + Math.random() * 0.3);
        const vx = -Math.sin(angle) * orbitalSpeed * 1.2;
        const vy = Math.cos(angle) * orbitalSpeed * 0.8;
        const vz = 0;
        
        const m = 0.8 + Math.random() * 2;
        const hue = 200 + arm * 60 + Math.random() * 40;
        bodies.push(new Body(x, y, z, vx, vy, vz, m, `hsl(${hue},100%,70%)`, 1));
    }
    updateInfo();
}

// ——— SOLAR SYSTEM TEMPLATE ———
function generateSolarSystem() {
    bodies = [];
    const cx = W/2, cy = H/2;
    const sun = new Body(cx, cy, 0, 0, 0, 0, 200, '#ff0', 1);
    sun.isSun = true;
    bodies.push(sun);

    const planets = [
        {r: 80, m: 3, color: '#888', speed: 1.2, name: 'Mercury'},
        {r: 120, m: 5, color: '#0f8', speed: 1.0, name: 'Venus'},
        {r: 160, m: 5, color: '#08f', speed: 0.9, name: 'Earth'},
        {r: 200, m: 4, color: '#f80', speed: 0.8, name: 'Mars'},
        {r: 280, m: 15, color: '#fa0', speed: 0.6, name: 'Jupiter'},
        {r: 360, m: 12, color: '#fc0', speed: 0.5, name: 'Saturn'}
    ];

    planets.forEach(planet => {
        const angle = Math.random() * Math.PI * 2;
        const x = cx + Math.cos(angle) * planet.r;
        const y = cy + Math.sin(angle) * planet.r;
        const orbitalSpeed = Math.sqrt(G * sun.m / planet.r) * planet.speed;
        const vx = -Math.sin(angle) * orbitalSpeed;
        const vy = Math.cos(angle) * orbitalSpeed;
        const body = new Body(x, y, 0, vx, vy, 0, planet.m, planet.color, 1);
        body.parent = sun;
        bodies.push(body);
    });
    updateInfo();
}

// ——— COLLISION DETECTION ———
function checkCollisions() {
    for (let i = 0; i < bodies.length; i++) {
        for (let j = i + 1; j < bodies.length; j++) {
            const b1 = bodies[i], b2 = bodies[j];
            if (b1.isStatic || b2.isStatic) continue;
            
            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const dz = b2.z - b1.z;
            const dist = Math.hypot(dx, dy, dz);
            
            if (dist < b1.r + b2.r) {
                // Merge bodies
                const totalMass = b1.m + b2.m;
                const newX = (b1.x * b1.m + b2.x * b2.m) / totalMass;
                const newY = (b1.y * b1.m + b2.y * b2.m) / totalMass;
                const newZ = (b1.z * b1.m + b2.z * b2.m) / totalMass;
                const newVX = (b1.vx * b1.m + b2.vx * b2.m) / totalMass;
                const newVY = (b1.vy * b1.m + b2.vy * b2.m) / totalMass;
                const newVZ = (b1.vz * b1.m + b2.vz * b2.m) / totalMass;
                
                // Create sparkles
                for (let k = 0; k < 10; k++) {
                    const v = 20 + Math.random() * 30;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    explosionParticles.push({
                        x: newX, y: newY, z: newZ,
                        vx: v * Math.sin(phi) * Math.cos(theta),
                        vy: v * Math.sin(phi) * Math.sin(theta),
                        vz: v * Math.cos(phi),
                        life: 0.5,
                        color: b1.m > b2.m ? b1.color : b2.color
                    });
                }
                
                const merged = new Body(newX, newY, newZ, newVX, newVY, newVZ, totalMass, b1.m > b2.m ? b1.color : b2.color, b1.charge);
                if (b1.isSun || b2.isSun) merged.isSun = true;
                
                bodies[i] = merged;
                bodies.splice(j, 1);
                j--;
                updateInfo();
            }
        }
    }
}

// ——— PARTICLE SYSTEM ———
function updateParticles(dt) {
    for (let i = explosionParticles.length - 1; i >= 0; i--) {
        const p = explosionParticles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.z += p.vz * dt;
        p.life -= dt;
        
        if (p.life <= 0) {
            explosionParticles.splice(i, 1);
        }
    }
}

function drawParticles() {
    explosionParticles.forEach(p => {
        const {sx, sy, scale} = p.project();
        if (scale <= 0) return;
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(sx, sy, 2 * scale, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;
}

// ——— INPUT HANDLING ———
let mouseDown = false, lastMouse = {x:0,y:0};
canvas.addEventListener('pointerdown', e => { 
    mouseDown = true; 
    lastMouse = {x:e.clientX, y:e.clientY}; 
});

canvas.addEventListener('pointermove', e => {
    if (mouseDown && is3D && !isDragging) {
        camera.rotY += (e.clientX - lastMouse.x) * 0.005;
        camera.rotX -= (e.clientY - lastMouse.y) * 0.005;
        camera.rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotX));
    }
    lastMouse = {x:e.clientX, y:e.clientY};
});

canvas.addEventListener('pointerup', () => mouseDown = false);

let isDragging = false, dragStart = {};
canvas.addEventListener('pointerdown', e => {
    if (e.button !== 0 || is3D) return;
    isDragging = true;
    dragStart = {x: e.clientX, y: e.clientY, px: e.clientX, py: e.clientY};
});

canvas.addEventListener('pointermove', e => { 
    if (isDragging) {
        dragStart.px = e.clientX; 
        dragStart.py = e.clientY; 
    }
});

canvas.addEventListener('pointerup', e => {
    if (!isDragging || e.button !== 0 || is3D) return;
    isDragging = false;
    const vx = (dragStart.x - e.clientX) * 0.1;
    const vy = (dragStart.y - e.clientY) * 0.1;
    const charge = isRepulsor ? -1 : 1;
    const color = isRepulsor ? '#ff3b30' : `hsl(${(bodies.length * 60) % 360},100%,70%)`;
    const m = isRepulsor ? mass * 1.5 : mass;
    bodies.push(new Body(dragStart.x, dragStart.y, 0, vx, vy, 0, m, color, charge));
    updateInfo();
});

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    camera.zoom *= e.deltaY < 0 ? 1.1 : 0.9;
    camera.zoom = Math.max(0.1, Math.min(10, camera.zoom));
}, { passive: false });

// ——— MAIN LOOP ———
let last = 0;
function loop(t) {
    const dt = Math.min((t - last) * 0.001 * speed, 0.1); 
    last = t;
    
    ctx.fillStyle = '#000'; 
    ctx.fillRect(0, 0, W, H);
    
    if (!paused) {
        // Build octree
        let minX = -W, maxX = W, minY = -H, maxY = H, minZ = -500, maxZ = 500;
        const size = Math.max(maxX-minX, maxY-minY, maxZ-minZ) * 2;
        const center = { x: (minX + maxX)/2, y: (minY + maxY)/2, z: (minZ + maxZ)/2 };
        rootNode = new OctreeNode(center, size);
        for (const body of bodies) if (body.m > 0) rootNode.insert(body);
        
        updateCamera(dt);
        
        // Update physics
        for (let b of bodies) {
            if (b.isStatic) continue;
            const force = rootNode.calculateForce(b, 0.5);
            b.ax = force.x; 
            b.ay = force.y; 
            b.az = force.z;
            b.applyPhysics(dt);
            b.updateEffects(dt);
        }
        
        checkCollisions();
        updateParticles(dt);
    }
    
    // Sort by depth for 3D
    if (is3D) bodies.sort((a,b) => b.z - a.z);
    
    // Draw everything
    bodies.forEach(b => b.draw());
    drawParticles();
    
    // Draw drag line
    if (isDragging) {
        ctx.strokeStyle = isRepulsor ? '#f00' : '#0ff';
        ctx.lineWidth = 2; 
        ctx.setLineDash([5,5]);
        ctx.beginPath(); 
        ctx.moveTo(dragStart.x, dragStart.y); 
        ctx.lineTo(dragStart.px, dragStart.py);
        ctx.stroke(); 
        ctx.setLineDash([]);
    }
    
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ——— UI HANDLERS ———
document.getElementById('pause').onclick = () => { 
    paused = !paused; 
    document.getElementById('pause').textContent = paused ? 'Play' : 'Pause'; 
};

document.getElementById('clear').onclick = () => { 
    bodies = []; 
    explosionParticles = []; 
    updateInfo(); 
};

document.getElementById('spiral').onclick = () => { 
    generateSpiralGalaxy(); 
};

document.getElementById('elliptical').onclick = () => { 
    generateEllipticalGalaxy(); 
};

document.getElementById('milky').onclick = () => { 
    generateMilkyWay(); 
};

document.getElementById('andromeda').onclick = () => { 
    generateAndromeda(); 
};

document.getElementById('solarSystem').onclick = () => { 
    generateSolarSystem(); 
};

document.getElementById('blackHole').onclick = () => { 
    bodies.push(new BlackHole(W/2, H/2, 10000)); 
    updateInfo(); 
};

document.getElementById('focus').onclick = () => {
    if (trackedBody) { 
        trackedBody = null; 
        document.getElementById('focus').textContent = "Focus Largest"; 
    } else if (bodies.length > 0) { 
        trackedBody = bodies.reduce((a, b) => a.m > b.m ? a : b); 
        document.getElementById('focus').textContent = "Unfocus"; 
    }
};

document.getElementById('repulsor').onclick = () => { 
    isRepulsor = !isRepulsor; 
    document.getElementById('repulsor').textContent = `Repulsor: ${isRepulsor?'ON':'OFF'}`; 
};

document.getElementById('darkMatter').onclick = () => { 
    darkMatter = !darkMatter; 
    document.getElementById('darkMatter').textContent = `Dark Matter: ${darkMatter?'ON':'OFF'}`; 
};

document.getElementById('threed').onclick = () => { 
    is3D = !is3D; 
    document.getElementById('threed').textContent = `3D: ${is3D?'ON':'OFF'}`; 
    camera.zoom = is3D ? 0.5 : 1; 
    camera.rotX = camera.rotY = 0; 
};

document.getElementById('trail').onclick = () => { 
    showTrail = !showTrail; 
    document.getElementById('trail').textContent = `Trail: ${showTrail?'ON':'OFF'}`; 
    if (!showTrail) bodies.forEach(b => b.trail = []); 
};

document.getElementById('mass').oninput = e => mass = +e.target.value;
document.getElementById('speed').oninput = e => speed = +e.target.value;

document.getElementById('save').onclick = () => { 
    const n = prompt("Galaxy name:", `Galaxy ${Date.now()}`); 
    if (n) saveGalaxy(n); 
};

document.getElementById('load').onclick = () => { 
    updateSaveList(); 
    const list = document.getElementById('saveList');
    list.style.display = list.style.display === 'none' ? 'block' : 'none';
};

document.getElementById('saveList').onclick = e => { 
    if (e.target.id === 'saveList') e.target.style.display = 'none'; 
};

function updateInfo() {
    let addHelp = is3D ? "WASD/QE to fly" : "Drag to add";
    if (isRepulsor) addHelp = "Drag for repulsor";
    document.getElementById('info').textContent = `Bodies: ${bodies.length} | ${addHelp} | F = G·m₁·m₂ / r²`;
}

updateInfo(); 
updateSaveList();
</script>
</body>
</html>
